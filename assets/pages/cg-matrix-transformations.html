<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x4 Matrix Transformations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        h1 {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 28px;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            padding: 20px;
        }
        
        .canvas-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        canvas {
            width: 100%;
            height: 500px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #1a1a2e;
        }
        
        .matrix-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        
        .matrix-title {
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 18px;
            color: #667eea;
            text-align: center;
        }
        
        .matrix {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-width: 400px;
            margin: 0 auto;
        }
        
        .matrix-cell {
            background: white;
            padding: 8px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-group h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .slider-value {
            color: #667eea;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #764ba2;
            transform: scale(1.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            background: #764ba2;
            transform: scale(1.2);
        }
        
        .reset-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .reset-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .reset-button:active {
            transform: translateY(0);
        }
        
        .info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #2196F3;
            font-size: 13px;
            line-height: 1.6;
            color: #1565c0;
        }
        
        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>4x4 Matrix Transformations Visualizer</h1>
        
        <div class="content">
            <div class="canvas-container">
                <canvas id="glCanvas"></canvas>
                
                <div class="matrix-display">
                    <div class="matrix-title">Final Transformation Matrix (4x4)</div>
                    <div class="matrix" id="matrixDisplay"></div>
                </div>
                
                <div class="info">
                    <strong>How it works:</strong> The cube is transformed by multiplying each vertex (vec4) by the transformation matrix. 
                    The matrix combines Translation × Rotation × Scale operations. Each slider updates the corresponding matrix values in real-time.
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h3>Translation</h3>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>X:</span>
                            <span class="slider-value" id="txValue">0.0</span>
                        </div>
                        <input type="range" id="tx" min="-5" max="5" step="0.1" value="0">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Y:</span>
                            <span class="slider-value" id="tyValue">0.0</span>
                        </div>
                        <input type="range" id="ty" min="-5" max="5" step="0.1" value="0">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Z:</span>
                            <span class="slider-value" id="tzValue">0.0</span>
                        </div>
                        <input type="range" id="tz" min="-5" max="5" step="0.1" value="0">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Rotation (degrees)</h3>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>X-axis:</span>
                            <span class="slider-value" id="rxValue">0°</span>
                        </div>
                        <input type="range" id="rx" min="0" max="360" step="1" value="0">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Y-axis:</span>
                            <span class="slider-value" id="ryValue">0°</span>
                        </div>
                        <input type="range" id="ry" min="0" max="360" step="1" value="0">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Z-axis:</span>
                            <span class="slider-value" id="rzValue">0°</span>
                        </div>
                        <input type="range" id="rz" min="0" max="360" step="1" value="0">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Scale</h3>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>X:</span>
                            <span class="slider-value" id="sxValue">1.0</span>
                        </div>
                        <input type="range" id="sx" min="0.1" max="3" step="0.1" value="1">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Y:</span>
                            <span class="slider-value" id="syValue">1.0</span>
                        </div>
                        <input type="range" id="sy" min="0.1" max="3" step="0.1" value="1">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Z:</span>
                            <span class="slider-value" id="szValue">1.0</span>
                        </div>
                        <input type="range" id="sz" min="0.1" max="3" step="0.1" value="1">
                    </div>
                </div>
                
                <button class="reset-button" onclick="resetTransform()">Reset to Identity Matrix</button>
            </div>
        </div>
    </div>

    <script>
        // WebGL setup
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }
        
        // Vertex shader
        const vsSource = `
            attribute vec4 aPosition;
            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            
            void main() {
                gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;
            }
        `;
        
        // Fragment shader
        const fsSource = `
            precision mediump float;
            
            void main() {
                gl_FragColor = vec4(0.3, 0.8, 1.0, 1.0);
            }
        `;
        
        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Create program
        function createProgram(gl, vsSource, fsSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }
        
        const program = createProgram(gl, vsSource, fsSource);
        
        // Cube vertices (wireframe)
        const vertices = new Float32Array([
            // Front face
            -1, -1,  1,
             1, -1,  1,
             
             1, -1,  1,
             1,  1,  1,
             
             1,  1,  1,
            -1,  1,  1,
            
            -1,  1,  1,
            -1, -1,  1,
            
            // Back face
            -1, -1, -1,
             1, -1, -1,
             
             1, -1, -1,
             1,  1, -1,
             
             1,  1, -1,
            -1,  1, -1,
            
            -1,  1, -1,
            -1, -1, -1,
            
            // Connecting edges
            -1, -1,  1,
            -1, -1, -1,
            
             1, -1,  1,
             1, -1, -1,
            
             1,  1,  1,
             1,  1, -1,
            
            -1,  1,  1,
            -1,  1, -1
        ]);
        
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const uModelMatrix = gl.getUniformLocation(program, 'uModelMatrix');
        const uViewMatrix = gl.getUniformLocation(program, 'uViewMatrix');
        const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
        
        // Matrix math functions
        function createIdentityMatrix() {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }
        
        function createTranslationMatrix(tx, ty, tz) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                tx, ty, tz, 1
            ];
        }
        
        function createRotationXMatrix(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                1, 0, 0, 0,
                0, c, s, 0,
                0, -s, c, 0,
                0, 0, 0, 1
            ];
        }
        
        function createRotationYMatrix(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                c, 0, -s, 0,
                0, 1, 0, 0,
                s, 0, c, 0,
                0, 0, 0, 1
            ];
        }
        
        function createRotationZMatrix(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                c, s, 0, 0,
                -s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }
        
        function createScaleMatrix(sx, sy, sz) {
            return [
                sx, 0, 0, 0,
                0, sy, 0, 0,
                0, 0, sz, 0,
                0, 0, 0, 1
            ];
        }
        
        function multiplyMatrices(a, b) {
            const result = new Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return result;
        }
        
        function createPerspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ];
        }
        
        function createLookAtMatrix(eye, center, up) {
            const zAxis = normalize([
                eye[0] - center[0],
                eye[1] - center[1],
                eye[2] - center[2]
            ]);
            const xAxis = normalize(cross(up, zAxis));
            const yAxis = cross(zAxis, xAxis);
            
            return [
                xAxis[0], yAxis[0], zAxis[0], 0,
                xAxis[1], yAxis[1], zAxis[1], 0,
                xAxis[2], yAxis[2], zAxis[2], 0,
                -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1
            ];
        }
        
        function normalize(v) {
            const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return [v[0] / len, v[1] / len, v[2] / len];
        }
        
        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }
        
        function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }
        
        // Transform state
        let transform = {
            tx: 0, ty: 0, tz: 0,
            rx: 0, ry: 0, rz: 0,
            sx: 1, sy: 1, sz: 1
        };
        
        // Setup sliders
        const sliders = ['tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy', 'sz'];
        sliders.forEach(id => {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + 'Value');
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                transform[id] = value;
                
                if (id.startsWith('r')) {
                    valueDisplay.textContent = value + '°';
                } else {
                    valueDisplay.textContent = value.toFixed(1);
                }
                
                render();
            });
        });
        
        function resetTransform() {
            transform = {
                tx: 0, ty: 0, tz: 0,
                rx: 0, ry: 0, rz: 0,
                sx: 1, sy: 1, sz: 1
            };
            
            document.getElementById('tx').value = 0;
            document.getElementById('ty').value = 0;
            document.getElementById('tz').value = 0;
            document.getElementById('rx').value = 0;
            document.getElementById('ry').value = 0;
            document.getElementById('rz').value = 0;
            document.getElementById('sx').value = 1;
            document.getElementById('sy').value = 1;
            document.getElementById('sz').value = 1;
            
            document.getElementById('txValue').textContent = '0.0';
            document.getElementById('tyValue').textContent = '0.0';
            document.getElementById('tzValue').textContent = '0.0';
            document.getElementById('rxValue').textContent = '0°';
            document.getElementById('ryValue').textContent = '0°';
            document.getElementById('rzValue').textContent = '0°';
            document.getElementById('sxValue').textContent = '1.0';
            document.getElementById('syValue').textContent = '1.0';
            document.getElementById('szValue').textContent = '1.0';
            
            render();
        }
        
        function updateMatrixDisplay(matrix) {
            const display = document.getElementById('matrixDisplay');
            display.innerHTML = '';
            
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'matrix-cell';
                cell.textContent = matrix[i].toFixed(3);
                display.appendChild(cell);
            }
        }
        
        function render() {
            // Resize canvas
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            // Clear
            gl.clearColor(0.1, 0.1, 0.18, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            
            // Create transformation matrices
            const scaleMatrix = createScaleMatrix(transform.sx, transform.sy, transform.sz);
            const rotXMatrix = createRotationXMatrix(transform.rx * Math.PI / 180);
            const rotYMatrix = createRotationYMatrix(transform.ry * Math.PI / 180);
            const rotZMatrix = createRotationZMatrix(transform.rz * Math.PI / 180);
            const translationMatrix = createTranslationMatrix(transform.tx, transform.ty, transform.tz);
            
            // Combine: Translation * RotationZ * RotationY * RotationX * Scale
            let modelMatrix = scaleMatrix;
            modelMatrix = multiplyMatrices(rotXMatrix, modelMatrix);
            modelMatrix = multiplyMatrices(rotYMatrix, modelMatrix);
            modelMatrix = multiplyMatrices(rotZMatrix, modelMatrix);
            modelMatrix = multiplyMatrices(translationMatrix, modelMatrix);
            
            // Update matrix display
            updateMatrixDisplay(modelMatrix);
            
            // View and projection matrices
            const viewMatrix = createLookAtMatrix([0, 0, 8], [0, 0, 0], [0, 1, 0]);
            const projectionMatrix = createPerspectiveMatrix(
                45 * Math.PI / 180,
                canvas.width / canvas.height,
                0.1,
                100
            );
            
            // Use program
            gl.useProgram(program);
            
            // Set uniforms
            gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
            gl.uniformMatrix4fv(uViewMatrix, false, viewMatrix);
            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
            
            // Set attribute
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
            
            // Draw wireframe cube
            gl.lineWidth(2);
            gl.drawArrays(gl.LINES, 0, vertices.length / 3);
        }
        
        // Initial render
        render();
        
        // Handle window resize
        window.addEventListener('resize', render);
    </script>
</body>
</html>